--------------------------------------------------------------------------------------
-- COMP214 Term Project: Airline Ticketing System
-- Final Integrated Script (Rubric-Ready Complete Version)
-- Fixes applied:
-- 1) Added missing 2nd Function: fn_booking_total
-- 2) Added missing 2nd Package Function: fx_booking_total
-- 3) Updated proc_cancel_booking to use CURSOR + EXCEPTION section (rubric)
-- 4) Added EXCEPTION section to proc_update_customer_contact (rubric)
-- 5) Added route unique constraint to prevent duplicate routes on re-runs
-- 6) Enhanced tests to show functions + trigger(audit) evidence
--------------------------------------------------------------------------------------

SET SERVEROUTPUT ON;
SET DEFINE OFF;

-- ===================================================================================
-- [STEP 1] CLEANUP
-- ===================================================================================
PROMPT Cleaning up old objects...
BEGIN
  FOR c IN (
    SELECT table_name
    FROM user_tables
    WHERE table_name IN ('TICKET_AUDIT','TICKET','BOOKING','CUSTOMER','SEAT_LAYOUT','FLIGHT','ROUTE','AIRCRAFT','AIRPORT')
  ) LOOP
    EXECUTE IMMEDIATE 'DROP TABLE ' || c.table_name || ' CASCADE CONSTRAINTS';
  END LOOP;

  FOR s IN (
    SELECT sequence_name
    FROM user_sequences
    WHERE sequence_name IN ('SEQ_CUSTOMER','SEQ_BOOKING','SEQ_TICKET','SEQ_CUST_UPDATE_CNT')
  ) LOOP
    EXECUTE IMMEDIATE 'DROP SEQUENCE ' || s.sequence_name;
  END LOOP;

  BEGIN EXECUTE IMMEDIATE 'DROP PACKAGE pkg_booking'; EXCEPTION WHEN OTHERS THEN NULL; END;
  BEGIN EXECUTE IMMEDIATE 'DROP PROCEDURE proc_update_customer_contact'; EXCEPTION WHEN OTHERS THEN NULL; END;
  BEGIN EXECUTE IMMEDIATE 'DROP PROCEDURE proc_change_seat'; EXCEPTION WHEN OTHERS THEN NULL; END;
  BEGIN EXECUTE IMMEDIATE 'DROP PROCEDURE proc_cancel_booking'; EXCEPTION WHEN OTHERS THEN NULL; END;
  BEGIN EXECUTE IMMEDIATE 'DROP FUNCTION fn_available_seats'; EXCEPTION WHEN OTHERS THEN NULL; END;
  BEGIN EXECUTE IMMEDIATE 'DROP FUNCTION fn_booking_total'; EXCEPTION WHEN OTHERS THEN NULL; END;
END;
/

-- ===================================================================================
-- [STEP 2] SCHEMA CREATION
-- ===================================================================================
PROMPT Creating Tables...

CREATE TABLE airport (
  airport_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  airport_code   CHAR(3) NOT NULL UNIQUE,
  name           VARCHAR2(100) NOT NULL,
  city           VARCHAR2(80) NOT NULL,
  country        VARCHAR2(80) NOT NULL
);

CREATE TABLE aircraft (
  aircraft_id    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  model          VARCHAR2(60) NOT NULL,
  tail_number    VARCHAR2(20) UNIQUE,
  total_seats    NUMBER NOT NULL
);

CREATE TABLE route (
  route_id               NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  departure_airport_id   NUMBER NOT NULL REFERENCES airport(airport_id),
  arrival_airport_id     NUMBER NOT NULL REFERENCES airport(airport_id),
  distance_km            NUMBER,
  economy_fare           NUMBER(8,2) NOT NULL,
  business_fare          NUMBER(8,2) NOT NULL,
  first_fare             NUMBER(8,2) NOT NULL,
  CONSTRAINT ck_route_diff_airport CHECK (departure_airport_id <> arrival_airport_id)
);

-- Prevent duplicate routes (helps with re-runs / seed)
ALTER TABLE route
  ADD CONSTRAINT uq_route_pair UNIQUE (departure_airport_id, arrival_airport_id);

CREATE TABLE flight (
  flight_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  route_id       NUMBER NOT NULL REFERENCES route(route_id),
  flight_number  VARCHAR2(10) NOT NULL,
  departure_ts   TIMESTAMP NOT NULL,
  arrival_ts     TIMESTAMP NOT NULL,
  aircraft_id    NUMBER NOT NULL REFERENCES aircraft(aircraft_id),
  status         VARCHAR2(20) DEFAULT 'SCHEDULED',
  CONSTRAINT ck_flight_status CHECK (status IN ('SCHEDULED', 'CANCELLED', 'DELAYED')),
  CONSTRAINT ck_flight_times CHECK (arrival_ts > departure_ts)
);

CREATE TABLE seat_layout (
  seat_id           NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  flight_id         NUMBER NOT NULL REFERENCES flight(flight_id) ON DELETE CASCADE,
  cabin_class       VARCHAR2(20) NOT NULL,
  seat_row          NUMBER NOT NULL,
  seat_col          CHAR(1) NOT NULL,
  seat_no           VARCHAR2(4) NOT NULL,
  is_exit_row       CHAR(1) DEFAULT 'N',
  is_extra_legroom  CHAR(1) DEFAULT 'N',
  is_wheelchair     CHAR(1) DEFAULT 'N',
  CONSTRAINT uq_seat UNIQUE (flight_id, seat_no),
  CONSTRAINT ck_cabin_class CHECK (cabin_class IN ('ECONOMY','BUSINESS','FIRST'))
);

CREATE TABLE customer (
  customer_id      NUMBER PRIMARY KEY,
  full_name        VARCHAR2(120) NOT NULL,
  contact_info     VARCHAR2(120),
  created_at       TIMESTAMP DEFAULT SYSTIMESTAMP,
  update_version   NUMBER DEFAULT 0
);

CREATE TABLE booking (
  booking_id    NUMBER PRIMARY KEY,
  customer_id   NUMBER NOT NULL REFERENCES customer(customer_id),
  flight_id     NUMBER NOT NULL REFERENCES flight(flight_id),
  pnr_code      VARCHAR2(6) NOT NULL,
  status        VARCHAR2(20) DEFAULT 'CONFIRMED',
  created_at    TIMESTAMP DEFAULT SYSTIMESTAMP,
  paid_flag     CHAR(1) DEFAULT 'N',
  CONSTRAINT uq_booking_pnr UNIQUE (pnr_code),
  CONSTRAINT ck_booking_status CHECK (status IN ('CONFIRMED','CANCELLED')),
  CONSTRAINT ck_paid_flag CHECK (paid_flag IN ('Y','N'))
);

CREATE TABLE ticket (
  ticket_id      NUMBER PRIMARY KEY,
  booking_id     NUMBER NOT NULL REFERENCES booking(booking_id),
  flight_id      NUMBER NOT NULL REFERENCES flight(flight_id),
  ticket_number  VARCHAR2(20) NOT NULL UNIQUE,
  seat_no        VARCHAR2(4) NOT NULL,
  cabin_class    VARCHAR2(20) NOT NULL,
  fare_amount    NUMBER(10,2) NOT NULL,
  status         VARCHAR2(20) DEFAULT 'ACTIVE',
  issued_at      TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT ck_ticket_status CHECK (status IN ('ACTIVE','VOID'))
);

CREATE TABLE ticket_audit (
  audit_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ticket_id     NUMBER NOT NULL,
  action        VARCHAR2(20) NOT NULL,
  seat_no       VARCHAR2(4),
  action_ts     TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT ck_ticket_audit_action CHECK (action IN ('INSERT','UPDATE'))
);

-- Constraints (composite FK support + seat existence)
ALTER TABLE booking
  ADD CONSTRAINT uq_booking_flight UNIQUE (booking_id, flight_id);

ALTER TABLE ticket
  ADD CONSTRAINT fk_ticket_booking_flight
  FOREIGN KEY (booking_id, flight_id)
  REFERENCES booking(booking_id, flight_id);

ALTER TABLE ticket
  ADD CONSTRAINT fk_ticket_seat
  FOREIGN KEY (flight_id, seat_no)
  REFERENCES seat_layout(flight_id, seat_no);

-- ===================================================================================
-- [STEP 3] SEQUENCES & TRIGGERS
-- ===================================================================================
PROMPT Creating Sequences and Triggers...

CREATE SEQUENCE seq_customer START WITH 1000 NOCACHE;
CREATE SEQUENCE seq_booking  START WITH 2000 NOCACHE;
CREATE SEQUENCE seq_ticket   START WITH 3000 NOCACHE;
CREATE SEQUENCE seq_cust_update_cnt START WITH 1 INCREMENT BY 1 NOCACHE;

CREATE OR REPLACE TRIGGER trg_customer_pk
BEFORE INSERT ON customer
FOR EACH ROW
WHEN (NEW.customer_id IS NULL)
BEGIN
  :NEW.customer_id := seq_customer.NEXTVAL;
END;
/

CREATE OR REPLACE TRIGGER trg_booking_pk
BEFORE INSERT ON booking
FOR EACH ROW
WHEN (NEW.booking_id IS NULL)
BEGIN
  :NEW.booking_id := seq_booking.NEXTVAL;
END;
/

CREATE OR REPLACE TRIGGER trg_ticket_pk
BEFORE INSERT ON ticket
FOR EACH ROW
BEGIN
  IF :NEW.ticket_id IS NULL THEN
    :NEW.ticket_id := seq_ticket.NEXTVAL;
  END IF;

  IF :NEW.ticket_number IS NULL THEN
    :NEW.ticket_number := '300' || TO_CHAR(:NEW.ticket_id);
  END IF;
END;
/

CREATE OR REPLACE TRIGGER trg_ticket_audit
AFTER INSERT OR UPDATE ON ticket
FOR EACH ROW
DECLARE
  v_action VARCHAR2(20);
BEGIN
  IF INSERTING THEN
    v_action := 'INSERT';
  ELSE
    v_action := 'UPDATE';
  END IF;

  INSERT INTO ticket_audit(ticket_id, action, seat_no)
  VALUES (:NEW.ticket_id, v_action, :NEW.seat_no);
END;
/

CREATE OR REPLACE TRIGGER trg_ticket_cabin_sync
BEFORE INSERT OR UPDATE ON ticket
FOR EACH ROW
DECLARE
  v_cabin seat_layout.cabin_class%TYPE;
BEGIN
  SELECT cabin_class
  INTO v_cabin
  FROM seat_layout
  WHERE flight_id = :NEW.flight_id
    AND seat_no   = :NEW.seat_no;

  :NEW.cabin_class := v_cabin;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20021, 'Seat does not exist for flight');
END;
/

-- Indexes (min 2 required)
CREATE INDEX idx_flight_route_time ON flight(route_id, departure_ts);
CREATE INDEX idx_ticket_flight     ON ticket(flight_id);
CREATE INDEX idx_booking_customer  ON booking(customer_id);

-- ===================================================================================
-- [STEP 4] PL/SQL LOGIC (Functions, Procedures, Package)
-- ===================================================================================
PROMPT Creating Business Logic...

-- Procedure 1: update using sequence + exception section (rubric)
CREATE OR REPLACE PROCEDURE proc_update_customer_contact(
    p_cust_id     IN customer.customer_id%TYPE,
    p_new_contact IN customer.contact_info%TYPE
) IS
  v_rows NUMBER;
BEGIN
  UPDATE customer
  SET contact_info   = p_new_contact,
      update_version = seq_cust_update_cnt.NEXTVAL
  WHERE customer_id = p_cust_id;

  v_rows := SQL%ROWCOUNT;

  IF v_rows = 0 THEN
    RAISE_APPLICATION_ERROR(-20041, 'Customer not found for update');
  END IF;

  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END;
/

-- Function 1
CREATE OR REPLACE FUNCTION fn_available_seats(p_flight_id NUMBER, p_cabin VARCHAR2)
RETURN NUMBER
IS
  v_total NUMBER;
  v_taken NUMBER;
BEGIN
  SELECT COUNT(*)
  INTO v_total
  FROM seat_layout
  WHERE flight_id = p_flight_id
    AND cabin_class = p_cabin;

  SELECT COUNT(*)
  INTO v_taken
  FROM ticket
  WHERE flight_id = p_flight_id
    AND cabin_class = p_cabin
    AND status = 'ACTIVE';

  RETURN v_total - v_taken;
EXCEPTION
  WHEN OTHERS THEN
    RETURN 0;
END;
/

-- Function 2 (added)
CREATE OR REPLACE FUNCTION fn_booking_total(p_booking_id NUMBER)
RETURN NUMBER
IS
  v_total NUMBER;
BEGIN
  SELECT SUM(fare_amount)
  INTO v_total
  FROM ticket
  WHERE booking_id = p_booking_id;

  RETURN NVL(v_total, 0);
EXCEPTION
  WHEN OTHERS THEN
    RETURN 0;
END;
/

-- Procedure 2: cursor + exception section (rubric)
CREATE OR REPLACE PROCEDURE proc_cancel_booking(p_pnr VARCHAR2) IS
  CURSOR c IS
    SELECT booking_id
    FROM booking
    WHERE pnr_code = p_pnr
    FOR UPDATE;

  v_booking_id booking.booking_id%TYPE;
BEGIN
  OPEN c;
  FETCH c INTO v_booking_id;

  IF c%NOTFOUND THEN
    CLOSE c;
    RAISE_APPLICATION_ERROR(-20014, 'PNR not found, cannot cancel');
  END IF;

  CLOSE c;

  UPDATE booking SET status = 'CANCELLED' WHERE booking_id = v_booking_id;
  UPDATE ticket  SET status = 'VOID'      WHERE booking_id = v_booking_id;

EXCEPTION
  WHEN OTHERS THEN
    RAISE;
END;
/

-- Package (must include >=2 procedures and >=2 functions)
CREATE OR REPLACE PACKAGE pkg_booking AS
  TYPE t_ticket_summary IS RECORD (
    ticket_number ticket.ticket_number%TYPE,
    seat_no       ticket.seat_no%TYPE
  );

  FUNCTION fx_available_seats(p_flight_id NUMBER, p_cabin VARCHAR2) RETURN NUMBER;
  FUNCTION fx_booking_total(p_booking_id NUMBER) RETURN NUMBER;

  PROCEDURE pr_create_booking(
    p_customer_name IN VARCHAR2,
    p_contact       IN VARCHAR2,
    p_flight_id     IN NUMBER,
    p_seat_no       IN VARCHAR2,
    o_pnr           OUT VARCHAR2,
    o_ticket        OUT t_ticket_summary
  );

  PROCEDURE pr_cancel_booking(p_pnr VARCHAR2);
END pkg_booking;
/

CREATE OR REPLACE PACKAGE BODY pkg_booking AS

  FUNCTION fx_available_seats(p_flight_id NUMBER, p_cabin VARCHAR2) RETURN NUMBER IS
  BEGIN
    RETURN fn_available_seats(p_flight_id, p_cabin);
  END;

  FUNCTION fx_booking_total(p_booking_id NUMBER) RETURN NUMBER IS
  BEGIN
    RETURN fn_booking_total(p_booking_id);
  END;

  PROCEDURE pr_create_booking(
    p_customer_name IN VARCHAR2,
    p_contact       IN VARCHAR2,
    p_flight_id     IN NUMBER,
    p_seat_no       IN VARCHAR2,
    o_pnr           OUT VARCHAR2,
    o_ticket        OUT t_ticket_summary
  ) IS
    v_cust_id NUMBER;
    v_bk_id   NUMBER;
    v_fare    NUMBER;
    v_cabin   VARCHAR2(20);
    v_dummy   NUMBER;
  BEGIN
    -- Ensure seat exists and get cabin
    SELECT cabin_class INTO v_cabin
    FROM seat_layout
    WHERE flight_id = p_flight_id
      AND seat_no   = p_seat_no;

    -- Ensure seat not already sold (simple check)
    SELECT COUNT(*) INTO v_dummy
    FROM ticket
    WHERE flight_id = p_flight_id
      AND seat_no   = p_seat_no
      AND status    = 'ACTIVE';

    IF v_dummy > 0 THEN
      RAISE_APPLICATION_ERROR(-20011, 'Seat already sold');
    END IF;

    -- Simplified fare logic (economy fare for assignment demo)
    SELECT r.economy_fare
    INTO v_fare
    FROM route r
    JOIN flight f ON f.route_id = r.route_id
    WHERE f.flight_id = p_flight_id;

    INSERT INTO customer(full_name, contact_info)
    VALUES (p_customer_name, p_contact)
    RETURNING customer_id INTO v_cust_id;

    -- 6-char PNR
    o_pnr := DBMS_RANDOM.STRING('U', 3) || LPAD(TRUNC(DBMS_RANDOM.VALUE(0,1000)), 3, '0');

    v_bk_id := seq_booking.NEXTVAL;

    INSERT INTO booking(booking_id, customer_id, flight_id, pnr_code, status, paid_flag)
    VALUES (v_bk_id, v_cust_id, p_flight_id, o_pnr, 'CONFIRMED', 'Y');

    INSERT INTO ticket(ticket_id, booking_id, flight_id, seat_no, cabin_class, fare_amount, status)
    VALUES (seq_ticket.NEXTVAL, v_bk_id, p_flight_id, p_seat_no, v_cabin, v_fare, 'ACTIVE')
    RETURNING ticket_number, seat_no INTO o_ticket;

  EXCEPTION
    WHEN OTHERS THEN
      RAISE;
  END;

  PROCEDURE pr_cancel_booking(p_pnr VARCHAR2) IS
  BEGIN
    proc_cancel_booking(p_pnr);
  END;

END pkg_booking;
/

-- ===================================================================================
-- [STEP 5] MASSIVE DATA SEEDING
-- ===================================================================================
PROMPT Generating massive seed data for Front-End (Please wait)...

-- Airports (lookup: >=5)
INSERT INTO airport(airport_code, name, city, country) VALUES ('YYZ', 'Toronto Pearson', 'Toronto', 'Canada');
INSERT INTO airport(airport_code, name, city, country) VALUES ('YVR', 'Vancouver Intl', 'Vancouver', 'Canada');
INSERT INTO airport(airport_code, name, city, country) VALUES ('YUL', 'Montreal Trudeau', 'Montreal', 'Canada');
INSERT INTO airport(airport_code, name, city, country) VALUES ('LAX', 'Los Angeles Intl', 'Los Angeles', 'USA');
INSERT INTO airport(airport_code, name, city, country) VALUES ('JFK', 'John F. Kennedy', 'New York', 'USA');

-- Aircraft (lookup-ish)
INSERT INTO aircraft(model, tail_number, total_seats) VALUES ('Boeing 737-8', 'FD-001', 174);
INSERT INTO aircraft(model, tail_number, total_seats) VALUES ('Airbus A321', 'FD-002', 185);

-- Routes (YYZ hub)
INSERT INTO route(departure_airport_id, arrival_airport_id, distance_km, economy_fare, business_fare, first_fare)
SELECT d.airport_id, a.airport_id, 3358, 320, 980, 1600
FROM airport d, airport a
WHERE d.airport_code='YYZ' AND a.airport_code='YVR';

INSERT INTO route(departure_airport_id, arrival_airport_id, distance_km, economy_fare, business_fare, first_fare)
SELECT d.airport_id, a.airport_id, 3358, 320, 980, 1600
FROM airport d, airport a
WHERE d.airport_code='YVR' AND a.airport_code='YYZ';

INSERT INTO route(departure_airport_id, arrival_airport_id, distance_km, economy_fare, business_fare, first_fare)
SELECT d.airport_id, a.airport_id, 500, 180, 620, 950
FROM airport d, airport a
WHERE d.airport_code='YYZ' AND a.airport_code='YUL';

INSERT INTO route(departure_airport_id, arrival_airport_id, distance_km, economy_fare, business_fare, first_fare)
SELECT d.airport_id, a.airport_id, 500, 180, 620, 950
FROM airport d, airport a
WHERE d.airport_code='YUL' AND a.airport_code='YYZ';

-- Flights + seats + bookings
DECLARE
  v_start     DATE := TRUNC(SYSDATE);
  v_ac1       NUMBER;
  v_flight_id NUMBER;
BEGIN
  SELECT aircraft_id INTO v_ac1 FROM aircraft WHERE tail_number = 'FD-001';

  FOR r IN (SELECT route_id, economy_fare FROM route) LOOP
    FOR v_day IN 0 .. 30 LOOP
      INSERT INTO flight(route_id, flight_number, departure_ts, arrival_ts, aircraft_id, status)
      VALUES (
        r.route_id,
        'FD' || LPAD(r.route_id, 3, '0') || TO_CHAR(v_day, 'FM00'),
        CAST(v_start+v_day AS TIMESTAMP) + 9/24,
        CAST(v_start+v_day AS TIMESTAMP) + 13/24,
        v_ac1,
        'SCHEDULED'
      )
      RETURNING flight_id INTO v_flight_id;

      -- Seats (Rows 1-10, A/B/C) => 30 seats per flight
      FOR row_n IN 1 .. 10 LOOP
        INSERT INTO seat_layout(flight_id, cabin_class, seat_row, seat_col, seat_no)
        VALUES (v_flight_id, 'ECONOMY', row_n, 'A', TO_CHAR(row_n)||'A');

        INSERT INTO seat_layout(flight_id, cabin_class, seat_row, seat_col, seat_no)
        VALUES (v_flight_id, 'ECONOMY', row_n, 'B', TO_CHAR(row_n)||'B');

        INSERT INTO seat_layout(flight_id, cabin_class, seat_row, seat_col, seat_no)
        VALUES (v_flight_id, 'ECONOMY', row_n, 'C', TO_CHAR(row_n)||'C');
      END LOOP;

      -- Two bookings per flight
      FOR k IN 1 .. 2 LOOP
        INSERT INTO customer(full_name, contact_info)
        VALUES ('Auto User '||v_flight_id||k, 'user'||k||'@auto.com');

        INSERT INTO booking(booking_id, customer_id, flight_id, pnr_code, status, paid_flag)
        VALUES (
          seq_booking.NEXTVAL,
          seq_customer.CURRVAL,
          v_flight_id,
          DBMS_RANDOM.STRING('U', 3) || LPAD(TRUNC(DBMS_RANDOM.VALUE(0,1000)), 3, '0'),
          'CONFIRMED',
          'Y'
        );

        INSERT INTO ticket(ticket_id, booking_id, flight_id, seat_no, cabin_class, fare_amount, status)
        VALUES (seq_ticket.NEXTVAL, seq_booking.CURRVAL, v_flight_id, TO_CHAR(k)||'A', 'ECONOMY', r.economy_fare, 'ACTIVE');
      END LOOP;
    END LOOP;
  END LOOP;

  COMMIT;
END;
/

PROMPT Massive Data Generation Complete.

-- ===================================================================================
-- [STEP 6] RUBRIC VALIDATION TESTS
-- ===================================================================================
PROMPT Running Rubric Validation Tests...

DECLARE
  v_cust_id NUMBER;
  v_flt_id  NUMBER;
  v_pnr     VARCHAR2(6);
  v_tkt     pkg_booking.t_ticket_summary;
  v_bk_id   NUMBER;
  v_audit_cnt NUMBER;
BEGIN
  -- Test 1: Sequence Update
  SELECT customer_id INTO v_cust_id FROM customer WHERE ROWNUM = 1;
  proc_update_customer_contact(v_cust_id, 'rubric_test@updated.com');
  DBMS_OUTPUT.PUT_LINE('Test 1 Passed: Customer '||v_cust_id||' updated using Sequence.');

  -- Test 2: Function call evidence
  SELECT flight_id INTO v_flt_id FROM flight WHERE status = 'SCHEDULED' AND ROWNUM = 1;
  DBMS_OUTPUT.PUT_LINE('Available ECON seats (function): ' || fn_available_seats(v_flt_id, 'ECONOMY'));

  -- Test 3: Package create + package functions
  pkg_booking.pr_create_booking('Pkg User', 'test@pkg.com', v_flt_id, '5A', v_pnr, v_tkt);
  DBMS_OUTPUT.PUT_LINE('Test 3 Passed: Booking created via Package. PNR: ' || v_pnr || ', Ticket: ' || v_tkt.ticket_number);

  SELECT booking_id INTO v_bk_id FROM booking WHERE pnr_code = v_pnr;
  DBMS_OUTPUT.PUT_LINE('Booking total (package function): ' || pkg_booking.fx_booking_total(v_bk_id));

  -- Test 4: Audit trigger evidence
  SELECT COUNT(*) INTO v_audit_cnt FROM ticket_audit WHERE ticket_id = (SELECT MAX(ticket_id) FROM ticket);
  DBMS_OUTPUT.PUT_LINE('Audit rows for most recent ticket: ' || v_audit_cnt);

  -- Test 5: Cancel via package
  pkg_booking.pr_cancel_booking(v_pnr);
  DBMS_OUTPUT.PUT_LINE('Test 5 Passed: Booking cancelled via Package.');
END;
/

PROMPT SCRIPT FINISHED SUCCESSFULLY.
SET DEFINE ON;