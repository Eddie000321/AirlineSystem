-- Airline ticketing schema bootstrap script for Oracle 12c
-- Run as the schema owner (one time) to create all tables, constraints,
-- sequences, and PL/SQL objects. Seed data is intentionally omitted.
-- Sections:
-- 1) Drop existing objects
-- 2) Create tables
-- 3) Create sequences
-- 4) Create triggers
-- 5) Create indexes
-- 6) Seed data (omitted; add your own)
-- 7) PL/SQL helpers (functions/procedures/package)

SET DEFINE OFF;

PROMPT Dropping old objects (ignore errors)...
BEGIN EXECUTE IMMEDIATE 'DROP TABLE ticket_audit CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TABLE ticket CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TABLE booking CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TABLE customer CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TABLE seat_layout CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TABLE flight CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TABLE route CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TABLE aircraft CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TABLE airport CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;
/

BEGIN EXECUTE IMMEDIATE 'DROP SEQUENCE seq_customer'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP SEQUENCE seq_booking'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP SEQUENCE seq_ticket'; EXCEPTION WHEN OTHERS THEN NULL; END;
/

BEGIN EXECUTE IMMEDIATE 'DROP PACKAGE pkg_booking'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP FUNCTION fn_available_seats'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP FUNCTION fn_booking_total'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP PROCEDURE proc_change_seat'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP PROCEDURE proc_cancel_booking'; EXCEPTION WHEN OTHERS THEN NULL; END;
/

PROMPT Creating tables...

CREATE TABLE airport (
  airport_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  airport_code   CHAR(3) NOT NULL UNIQUE,
  name           VARCHAR2(100) NOT NULL,
  city           VARCHAR2(80) NOT NULL,
  country        VARCHAR2(80) NOT NULL
);

CREATE TABLE aircraft (
  aircraft_id    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  model          VARCHAR2(60) NOT NULL,
  tail_number    VARCHAR2(20) UNIQUE,
  total_seats    NUMBER NOT NULL
);

CREATE TABLE route (
  route_id               NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  departure_airport_id   NUMBER NOT NULL REFERENCES airport(airport_id),
  arrival_airport_id     NUMBER NOT NULL REFERENCES airport(airport_id),
  distance_km            NUMBER,
  economy_fare           NUMBER(8,2) NOT NULL,
  business_fare          NUMBER(8,2) NOT NULL,
  first_fare             NUMBER(8,2) NOT NULL,
  CONSTRAINT ck_route_diff_airport CHECK (departure_airport_id <> arrival_airport_id)
);

CREATE TABLE flight (
  flight_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  route_id       NUMBER NOT NULL REFERENCES route(route_id),
  flight_number  VARCHAR2(10) NOT NULL,
  departure_ts   TIMESTAMP NOT NULL,
  arrival_ts     TIMESTAMP NOT NULL,
  aircraft_id    NUMBER NOT NULL REFERENCES aircraft(aircraft_id),
  status         VARCHAR2(20) DEFAULT 'SCHEDULED',
  CONSTRAINT ck_flight_status CHECK (status IN ('SCHEDULED', 'CANCELLED', 'DELAYED')),
  CONSTRAINT ck_flight_times CHECK (arrival_ts > departure_ts)
);

CREATE TABLE seat_layout (
  seat_id           NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  flight_id         NUMBER NOT NULL REFERENCES flight(flight_id) ON DELETE CASCADE,
  cabin_class       VARCHAR2(20) NOT NULL,
  seat_row          NUMBER NOT NULL,
  seat_col          CHAR(1) NOT NULL,
  seat_no           VARCHAR2(4) NOT NULL,
  is_exit_row       CHAR(1) DEFAULT 'N',
  is_extra_legroom  CHAR(1) DEFAULT 'N',
  is_wheelchair     CHAR(1) DEFAULT 'N',
  CONSTRAINT uq_seat UNIQUE (flight_id, seat_no),
  CONSTRAINT ck_seat_flags CHECK (
    is_exit_row IN ('Y','N') AND
    is_extra_legroom IN ('Y','N') AND
    is_wheelchair IN ('Y','N')
  ),
  CONSTRAINT ck_seat_cabin CHECK (cabin_class IN ('ECONOMY','BUSINESS','FIRST'))
);

CREATE TABLE customer (
  customer_id   NUMBER PRIMARY KEY,
  full_name     VARCHAR2(120) NOT NULL,
  contact_info  VARCHAR2(120),
  created_at    TIMESTAMP DEFAULT SYSTIMESTAMP
);

CREATE TABLE booking (
  booking_id    NUMBER PRIMARY KEY,
  customer_id   NUMBER NOT NULL REFERENCES customer(customer_id),
  flight_id     NUMBER NOT NULL REFERENCES flight(flight_id),
  pnr_code      VARCHAR2(6) NOT NULL,
  status        VARCHAR2(20) DEFAULT 'CONFIRMED',
  created_at    TIMESTAMP DEFAULT SYSTIMESTAMP,
  paid_flag     CHAR(1) DEFAULT 'N',
  CONSTRAINT ck_booking_status CHECK (status IN ('CONFIRMED','CANCELLED')),
  CONSTRAINT ck_booking_paid CHECK (paid_flag IN ('Y','N')),
  CONSTRAINT uq_booking_pnr UNIQUE (pnr_code)
);

CREATE TABLE ticket (
  ticket_id      NUMBER PRIMARY KEY,
  booking_id     NUMBER NOT NULL REFERENCES booking(booking_id),
  flight_id      NUMBER NOT NULL REFERENCES flight(flight_id),
  ticket_number  VARCHAR2(20) NOT NULL UNIQUE,
  seat_no        VARCHAR2(4) NOT NULL,
  cabin_class    VARCHAR2(20) NOT NULL,
  fare_amount    NUMBER(10,2) NOT NULL,
  status         VARCHAR2(20) DEFAULT 'ACTIVE',
  issued_at      TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT ck_ticket_status CHECK (status IN ('ACTIVE','VOID')),
  CONSTRAINT ck_ticket_cabin CHECK (cabin_class IN ('ECONOMY','BUSINESS','FIRST'))
);

CREATE TABLE ticket_audit (
  audit_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ticket_id     NUMBER NOT NULL,
  action        VARCHAR2(20) NOT NULL,
  seat_no       VARCHAR2(4),
  action_ts     TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT ck_ticket_audit_action CHECK (action IN ('INSERT','UPDATE','DELETE'))
);

-- Additional integrity constraints
ALTER TABLE booking
  ADD CONSTRAINT uq_booking_flight UNIQUE (booking_id, flight_id);

ALTER TABLE ticket
  ADD CONSTRAINT fk_ticket_booking_flight
  FOREIGN KEY (booking_id, flight_id) REFERENCES booking(booking_id, flight_id);

ALTER TABLE ticket
  ADD CONSTRAINT fk_ticket_seat
  FOREIGN KEY (flight_id, seat_no) REFERENCES seat_layout(flight_id, seat_no);

ALTER TABLE ticket_audit
  ADD CONSTRAINT fk_ticket_audit_ticket
  FOREIGN KEY (ticket_id) REFERENCES ticket(ticket_id) ON DELETE CASCADE;

PROMPT Creating sequences...
-- PK/key generators for core tables

CREATE SEQUENCE seq_customer START WITH 1000 NOCACHE;
CREATE SEQUENCE seq_booking START WITH 2000 NOCACHE;
CREATE SEQUENCE seq_ticket START WITH 3000 NOCACHE;

PROMPT Creating triggers for PK defaults and audits...
-- Default PK assignment + ticket audit trail on DML

CREATE OR REPLACE TRIGGER trg_customer_pk
BEFORE INSERT ON customer
FOR EACH ROW
WHEN (NEW.customer_id IS NULL)
BEGIN
  :NEW.customer_id := seq_customer.NEXTVAL;
END;
/

CREATE OR REPLACE TRIGGER trg_booking_pk
BEFORE INSERT ON booking
FOR EACH ROW
WHEN (NEW.booking_id IS NULL)
BEGIN
  :NEW.booking_id := seq_booking.NEXTVAL;
END;
/

CREATE OR REPLACE TRIGGER trg_ticket_pk
BEFORE INSERT ON ticket
FOR EACH ROW
BEGIN
  IF :NEW.ticket_id IS NULL THEN
    :NEW.ticket_id := seq_ticket.NEXTVAL;
  END IF;
  IF :NEW.ticket_number IS NULL THEN
    :NEW.ticket_number := '300' || TO_CHAR(:NEW.ticket_id);
  END IF;
END;
/

CREATE OR REPLACE TRIGGER trg_ticket_audit
AFTER INSERT OR UPDATE ON ticket
FOR EACH ROW
DECLARE
  v_action VARCHAR2(20);
  v_seat   VARCHAR2(4);
BEGIN
  IF INSERTING THEN
    v_action := 'INSERT';
    v_seat := :NEW.seat_no;
  ELSE
    v_action := 'UPDATE';
    v_seat := :NEW.seat_no;
  END IF;

  INSERT INTO ticket_audit(ticket_id, action, seat_no)
  VALUES (:NEW.ticket_id, v_action, v_seat);
END;
/

-- Keep ticket.cabin_class aligned with seat_layout for the flight/seat
CREATE OR REPLACE TRIGGER trg_ticket_cabin_sync
BEFORE INSERT OR UPDATE ON ticket
FOR EACH ROW
DECLARE
  v_cabin seat_layout.cabin_class%TYPE;
BEGIN
  SELECT cabin_class INTO v_cabin
  FROM seat_layout
  WHERE flight_id = :NEW.flight_id
    AND seat_no = :NEW.seat_no;

  :NEW.cabin_class := v_cabin;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20021, 'Seat does not exist for flight');
END;
/

PROMPT Creating indexes...

CREATE INDEX idx_flight_route_time ON flight(route_id, departure_ts);
CREATE INDEX idx_ticket_flight ON ticket(flight_id);
CREATE INDEX idx_booking_customer ON booking(customer_id);
CREATE INDEX idx_seat_layout_flight ON seat_layout(flight_id);
CREATE INDEX idx_ticket_booking ON ticket(booking_id);
CREATE UNIQUE INDEX uq_ticket_active_seat ON ticket (
  flight_id,
  CASE WHEN status = 'ACTIVE' THEN seat_no END
);

PROMPT Seed data skipped (populate your own demo data as needed).

PROMPT Creating helper functions & procedures...
-- Business logic utilities (availability, totals, seat change, cancel)

CREATE OR REPLACE FUNCTION fn_available_seats(p_flight_id NUMBER, p_cabin VARCHAR2)
RETURN NUMBER
IS
  v_total NUMBER;
  v_taken NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_total
  FROM seat_layout
  WHERE flight_id = p_flight_id
    AND cabin_class = p_cabin;

  SELECT COUNT(*) INTO v_taken
  FROM ticket
  WHERE flight_id = p_flight_id
    AND cabin_class = p_cabin
    AND status = 'ACTIVE';

  RETURN v_total - v_taken;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN 0;
END;
/

CREATE OR REPLACE FUNCTION fn_booking_total(p_booking_id NUMBER)
RETURN NUMBER
IS
  v_total NUMBER;
BEGIN
  SELECT SUM(fare_amount) INTO v_total
  FROM ticket
  WHERE booking_id = p_booking_id;
  RETURN NVL(v_total, 0);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN 0;
END;
/

CREATE OR REPLACE PROCEDURE proc_change_seat(
  p_ticket_id  IN ticket.ticket_id%TYPE,
  p_seat_no    IN ticket.seat_no%TYPE
) IS
  v_ticket_row ticket%ROWTYPE;
  v_taken NUMBER;
  v_seat_exists NUMBER;
BEGIN
  SELECT * INTO v_ticket_row
  FROM ticket
  WHERE ticket_id = p_ticket_id
  FOR UPDATE;

  SELECT COUNT(*) INTO v_seat_exists
  FROM seat_layout
  WHERE flight_id = v_ticket_row.flight_id
    AND seat_no = p_seat_no;

  IF v_seat_exists = 0 THEN
    RAISE_APPLICATION_ERROR(-20021, 'Seat does not exist for flight');
  END IF;

  SELECT COUNT(*) INTO v_taken
  FROM ticket
  WHERE flight_id = v_ticket_row.flight_id
    AND seat_no = p_seat_no
    AND status = 'ACTIVE'
    AND ticket_id <> p_ticket_id;

  IF v_taken > 0 THEN
    RAISE_APPLICATION_ERROR(-20010, 'Seat already taken');
  END IF;

  UPDATE ticket
  SET seat_no = p_seat_no
  WHERE ticket_id = p_ticket_id;
  -- status remains as-is; audit trigger will log the change
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20013, 'Ticket not found for seat change');
  WHEN OTHERS THEN
    RAISE;
END;
/

CREATE OR REPLACE PROCEDURE proc_cancel_booking(p_pnr VARCHAR2) IS
  CURSOR c_booking IS
    SELECT booking_id
    FROM booking
    WHERE pnr_code = p_pnr
    FOR UPDATE;
  v_booking_id booking.booking_id%TYPE;
BEGIN
  OPEN c_booking;
  FETCH c_booking INTO v_booking_id;
  IF c_booking%NOTFOUND THEN
    CLOSE c_booking;
    RAISE_APPLICATION_ERROR(-20014, 'PNR not found, cannot cancel');
  END IF;
  CLOSE c_booking;

  UPDATE booking SET status = 'CANCELLED'
  WHERE booking_id = v_booking_id;

  UPDATE ticket SET status = 'VOID'
  WHERE booking_id = v_booking_id;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20015, 'PNR not found (no_data_found)');
  WHEN OTHERS THEN
    RAISE;
END;
/

PROMPT Building package with shared procedures/functions...
-- pkg_booking wraps helpers and exposes booking create/cancel with PNR generator

CREATE OR REPLACE PACKAGE pkg_booking AS
  g_issue_channel CONSTANT VARCHAR2(20) := 'WEB_PORTAL';
  SUBTYPE t_pnr_code IS booking.pnr_code%TYPE;

  TYPE t_ticket_summary IS RECORD (
    ticket_number ticket.ticket_number%TYPE,
    seat_no       ticket.seat_no%TYPE,
    cabin         ticket.cabin_class%TYPE
  );

  FUNCTION fx_available_seats(p_flight_id NUMBER, p_cabin VARCHAR2) RETURN NUMBER;
  FUNCTION fx_booking_total(p_booking_id NUMBER) RETURN NUMBER;
  PROCEDURE pr_create_booking(
    p_customer_name   IN customer.full_name%TYPE,
    p_contact         IN customer.contact_info%TYPE,
    p_flight_id       IN flight.flight_id%TYPE,
    p_seat_no         IN ticket.seat_no%TYPE,
    o_pnr             OUT booking.pnr_code%TYPE,
    o_ticket          OUT t_ticket_summary
  );
  PROCEDURE pr_cancel_booking(p_pnr VARCHAR2);
END pkg_booking;
/

CREATE OR REPLACE PACKAGE BODY pkg_booking AS
  g_private_prefix CONSTANT VARCHAR2(6) := 'PNR-';
  g_last_pnr booking.pnr_code%TYPE;

  FUNCTION next_pnr RETURN booking.pnr_code%TYPE IS
    v_candidate booking.pnr_code%TYPE;
    v_exists NUMBER;
  BEGIN
    FOR attempt IN 1 .. 20 LOOP
      v_candidate := DBMS_RANDOM.STRING('A', 3) || LPAD(TRUNC(DBMS_RANDOM.VALUE(0, 1000)), 3, '0');

      SELECT COUNT(*) INTO v_exists
      FROM booking
      WHERE pnr_code = v_candidate;

      IF v_exists = 0 THEN
        g_last_pnr := v_candidate;
        RETURN g_last_pnr;
      END IF;
    END LOOP;

    RAISE_APPLICATION_ERROR(-20031, 'Unable to generate unique PNR after retries');
  END;

  FUNCTION fx_available_seats(p_flight_id NUMBER, p_cabin VARCHAR2) RETURN NUMBER IS
  BEGIN
    RETURN fn_available_seats(p_flight_id, p_cabin);
  END;

  FUNCTION fx_booking_total(p_booking_id NUMBER) RETURN NUMBER IS
  BEGIN
    RETURN fn_booking_total(p_booking_id);
  END;

  PROCEDURE pr_create_booking(
    p_customer_name   IN customer.full_name%TYPE,
    p_contact         IN customer.contact_info%TYPE,
    p_flight_id       IN flight.flight_id%TYPE,
    p_seat_no         IN ticket.seat_no%TYPE,
    o_pnr             OUT booking.pnr_code%TYPE,
    o_ticket          OUT t_ticket_summary
  ) IS
    v_booking_id booking.booking_id%TYPE;
    v_customer_id customer.customer_id%TYPE;
    v_taken NUMBER;
    v_fare NUMBER;
    v_econ route.economy_fare%TYPE;
    v_biz route.business_fare%TYPE;
    v_first route.first_fare%TYPE;
    v_cabin seat_layout.cabin_class%TYPE;
  BEGIN
    SELECT COUNT(*) INTO v_taken
    FROM ticket
    WHERE flight_id = p_flight_id
      AND seat_no = p_seat_no
      AND status = 'ACTIVE';

    IF v_taken > 0 THEN
      RAISE_APPLICATION_ERROR(-20011, 'Seat already sold.');
    END IF;

    SELECT cabin_class INTO v_cabin
    FROM seat_layout
    WHERE flight_id = p_flight_id
      AND seat_no = p_seat_no;

    SELECT r.economy_fare, r.business_fare, r.first_fare
    INTO v_econ, v_biz, v_first
    FROM route r
    JOIN flight f ON f.route_id = r.route_id
    WHERE f.flight_id = p_flight_id;

    v_fare := CASE v_cabin WHEN 'ECONOMY' THEN v_econ WHEN 'BUSINESS' THEN v_biz ELSE v_first END;

    INSERT INTO customer(customer_id, full_name, contact_info)
    VALUES (seq_customer.NEXTVAL, p_customer_name, p_contact)
    RETURNING customer_id INTO v_customer_id;

    FOR attempt IN 1 .. 20 LOOP
      v_booking_id := seq_booking.NEXTVAL;
      o_pnr := next_pnr;

      BEGIN
        INSERT INTO booking(booking_id, customer_id, flight_id, pnr_code, status, paid_flag)
        VALUES (v_booking_id, v_customer_id, p_flight_id, o_pnr, 'CONFIRMED', 'Y');

        INSERT INTO ticket(ticket_id, booking_id, flight_id, seat_no, cabin_class, fare_amount, status)
        VALUES (seq_ticket.NEXTVAL, v_booking_id, p_flight_id, p_seat_no, v_cabin, v_fare, 'ACTIVE')
        RETURNING ticket_number, seat_no, cabin_class INTO o_ticket;

        RETURN;
      EXCEPTION
        WHEN dup_val_on_index THEN
          IF INSTR(SQLERRM, 'UQ_BOOKING_PNR') > 0 THEN
            IF attempt = 20 THEN
              RAISE_APPLICATION_ERROR(-20030, 'Unable to allocate unique PNR');
            END IF;
          ELSE
            RAISE;
          END IF;
      END;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      RAISE;
  END;

  PROCEDURE pr_cancel_booking(p_pnr VARCHAR2) IS
  BEGIN
    proc_cancel_booking(p_pnr);
  END;
END pkg_booking;
/

PROMPT Sample tests (run separately)
-- @sql/tests.sql

SET DEFINE ON;
